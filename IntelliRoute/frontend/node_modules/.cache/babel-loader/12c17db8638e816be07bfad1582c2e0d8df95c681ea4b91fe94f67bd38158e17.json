{"ast":null,"code":"var _jsxFileName = \"/home/anubhav/project_6/auth-system/frontend/src/context/ChatContext.js\",\n  _s = $RefreshSig$();\nimport React, { createContext, useState, useEffect, useContext, useCallback, useRef } from 'react';\nimport api from '../utils/api';\nimport { AuthContext } from './AuthContext';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const ChatContext = /*#__PURE__*/createContext();\nexport const ChatProvider = ({\n  children\n}) => {\n  _s();\n  const {\n    user\n  } = useContext(AuthContext);\n  const [activeChats, setActiveChats] = useState([]);\n  const [notifications, setNotifications] = useState([]);\n  const [currentChat, setCurrentChat] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Add these to track last request times\n  const lastRequest = useRef({\n    chat: 0,\n    notifications: 0,\n    messages: 0\n  });\n\n  // Add this to prevent concurrent requests\n  const pendingRequests = useRef({\n    chat: false,\n    notifications: false,\n    messages: false\n  });\n\n  // Add the missing enforceApiDelay function\n  const enforceApiDelay = useCallback(async (requestType, minDelay = 2000) => {\n    if (pendingRequests.current[requestType]) {\n      console.log(`${requestType} request already in progress, skipping`);\n      return false;\n    }\n    const now = Date.now();\n    if (now - lastRequest.current[requestType] < minDelay) {\n      console.log(`Throttling ${requestType} request, too soon`);\n      return false;\n    }\n    pendingRequests.current[requestType] = true;\n    lastRequest.current[requestType] = now;\n    return true;\n  }, []);\n\n  // Throttled fetch notifications\n  const fetchNotifications = useCallback(async (force = false) => {\n    if (!user) return [];\n\n    // Don't allow concurrent requests\n    if (pendingRequests.current.notifications) {\n      console.log('Notification request already in progress, skipping');\n      return notifications;\n    }\n    const now = Date.now();\n    // Only fetch if it's been more than 10 seconds since last check or forced\n    if (!force && now - lastRequest.current.notifications < 10000) {\n      return notifications; // Return cached notifications\n    }\n    try {\n      pendingRequests.current.notifications = true;\n      console.log('Fetching notifications...');\n      const response = await api.get('/chat/notifications');\n      lastRequest.current.notifications = now;\n\n      // Only update state if the notifications have changed\n      const newNotifications = response.data.notifications || [];\n      if (JSON.stringify(newNotifications) !== JSON.stringify(notifications)) {\n        setNotifications(newNotifications);\n      }\n      return newNotifications;\n    } catch (error) {\n      console.error('Error fetching notifications:', error);\n      return [];\n    } finally {\n      pendingRequests.current.notifications = false;\n    }\n  }, [user, notifications]);\n\n  // Throttled fetch active chats\n  const fetchActiveChats = useCallback(async (force = false) => {\n    if (!user) return [];\n\n    // Don't allow concurrent requests\n    if (pendingRequests.current.chat) {\n      console.log('Chat request already in progress, skipping');\n      return activeChats;\n    }\n    const now = Date.now();\n    // Only fetch if it's been more than 10 seconds since last check or forced\n    if (!force && now - lastRequest.current.chat < 10000) {\n      return activeChats; // Return cached chats\n    }\n    try {\n      pendingRequests.current.chat = true;\n      setLoading(true);\n      console.log('Fetching active chats...');\n      const response = await api.get('/chat/active');\n      lastRequest.current.chat = now;\n      const newChats = response.data.chats || [];\n\n      // Only update state if the chats have changed\n      if (JSON.stringify(newChats) !== JSON.stringify(activeChats)) {\n        console.log('Updating active chats, found changes');\n        setActiveChats(newChats);\n      } else {\n        console.log('No changes in active chats');\n      }\n      return newChats;\n    } catch (error) {\n      console.error('Error fetching active chats:', error);\n      setError('Failed to fetch active chats');\n      return [];\n    } finally {\n      setLoading(false);\n      pendingRequests.current.chat = false;\n    }\n  }, [user, activeChats]);\n\n  // Send a chat request to another user\n  const sendChatRequest = async recipientId => {\n    if (!user || !recipientId) return;\n    try {\n      setLoading(true);\n      console.log('Sending chat request to:', recipientId);\n      const response = await api.post('/chat/request', {\n        recipientId\n      });\n\n      // Force refresh active chats\n\n      await fetchActiveChats(true);\n\n      // Store the chat request ID for monitoring\n      localStorage.setItem('pendingChatRequest', response.data.chatRoomId);\n      return response.data;\n    } catch (error) {\n      var _error$response, _error$response$data;\n      console.error('Error sending chat request:', error);\n      setError('Failed to send chat request: ' + (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || error.message));\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Accept a chat request\n\n  const acceptChatRequest = async chatRoomId => {\n    if (!user || !chatRoomId) return;\n    try {\n      setLoading(true);\n      console.log('Accepting chat request:', chatRoomId);\n      const response = await api.post('/chat/accept', {\n        chatRoomId\n      });\n      console.log('Accept response:', response.data);\n\n      // Force refresh notifications and active chats\n\n      await fetchNotifications(true);\n      const updatedChats = await fetchActiveChats(true);\n      console.log('Looking for chat room in active chats');\n      const acceptedChat = updatedChats.find(c => c.id === chatRoomId);\n      if (acceptedChat) {\n        console.log('Found accepted chat, opening it:', acceptedChat);\n        setCurrentChat(acceptedChat);\n\n        // Fetch messages for this chat\n        await fetchMessages(chatRoomId);\n      } else {\n        console.error('Accepted chat not found in active chats. Will retry...');\n        // Retry once after a delay\n\n        setTimeout(async () => {\n          const retryChats = await fetchActiveChats(true);\n          const retryChat = retryChats.find(c => c.id === chatRoomId);\n          if (retryChat) {\n            console.log('Found chat on retry');\n            setCurrentChat(retryChat);\n            await fetchMessages(chatRoomId);\n          }\n        }, 2000);\n      }\n      return response.data;\n    } catch (error) {\n      console.error('Error accepting chat request:', error);\n      setError('Failed to accept chat request: ' + (error.message || 'Unknown error'));\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Decline a chat request\n\n  const declineChatRequest = async chatRoomId => {\n    if (!user || !chatRoomId) return;\n    try {\n      setLoading(true);\n      console.log(`[${new Date().toISOString()}] Declining chat request: ${chatRoomId}...`);\n\n      // Add artificial delay of 1 second\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      const response = await api.post('/chat/decline', {\n        chatRoomId\n      });\n\n      // Force refresh notifications\n\n      await fetchNotifications(true);\n      return response.data;\n    } catch (error) {\n      console.error('Error declining chat request:', error);\n      setError('Failed to decline chat request');\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Send a message in a chat with enhanced error handling\n  const sendMessage = async (chatRoomId, message) => {\n    if (!user || !chatRoomId || !message) return;\n    try {\n      console.log('Sending message to room:', chatRoomId);\n      const response = await api.post('/chat/send', {\n        chatRoomId,\n        message\n      });\n\n      // Add the new message to the state\n      const newMessage = response.data.chatMessage;\n      setMessages(prev => [...prev, {\n        ...newMessage,\n        profiles: {\n          username: user.username\n        }\n      }]);\n      return response.data;\n    } catch (error) {\n      console.error('Error sending message:', error);\n      setError('Failed to send message: ' + error.message);\n      throw error;\n    }\n  };\n\n  // Fetch messages for a chat with better error handling and throttling\n  const fetchMessages = useCallback(async (chatRoomId, force = false) => {\n    if (!user || !chatRoomId) return;\n\n    // If we already have an active chat and it's not forced, enforce delay\n    if (currentChat && !force && !(await enforceApiDelay('messages'))) {\n      return messages; // Return cached messages\n    }\n    try {\n      setLoading(true);\n      console.log('Fetching messages for room:', chatRoomId);\n      const response = await api.get(`/chat/messages/${chatRoomId}`);\n      setMessages(response.data.messages || []);\n      return response.data.messages;\n    } catch (error) {\n      console.error('Error fetching messages:', error);\n      setError('Failed to fetch messages: ' + error.message);\n      setMessages([]);\n      return [];\n    } finally {\n      setLoading(false);\n      pendingRequests.current.messages = false;\n    }\n  }, [user, messages, currentChat, enforceApiDelay]);\n\n  // Open a chat\n  const openChat = useCallback(async chatRoomId => {\n    try {\n      console.log('Opening chat:', chatRoomId);\n\n      // First check if this chat is in our current active chats\n      let chat = activeChats.find(c => c.id === chatRoomId);\n\n      // If not found, try fetching fresh data\n\n      if (!chat) {\n        console.log('Chat not found in current state, fetching fresh data');\n        const updatedChats = await fetchActiveChats(true);\n        chat = updatedChats.find(c => c.id === chatRoomId);\n      }\n      if (chat) {\n        console.log('Setting current chat:', chat);\n        setCurrentChat(chat);\n        await fetchMessages(chatRoomId);\n      } else {\n        console.error('Chat not found in active chats');\n        setError('Chat not found');\n      }\n    } catch (error) {\n      console.error('Error opening chat:', error);\n      setError('Failed to open chat: ' + error.message);\n    }\n  }, [activeChats, fetchActiveChats, fetchMessages]);\n\n  // Close the current chat\n  const closeChat = () => {\n    setCurrentChat(null);\n    setMessages([]);\n  };\n\n  // Set up polling at a reasonable rate (once per 10 seconds)\n  useEffect(() => {\n    if (user) {\n      // Initial load\n      fetchNotifications(true);\n      fetchActiveChats(true);\n\n      // Check for any pending chat requests\n\n      const pendingChatId = localStorage.getItem('pendingChatRequest');\n      if (pendingChatId) {\n        console.log('Found pending chat request, checking status:', pendingChatId);\n        fetchActiveChats(true).then(chats => {\n          const pendingChat = chats.find(c => c.id === pendingChatId);\n          if (pendingChat && pendingChat.hasJoined) {\n            console.log('Pending chat has been accepted, opening');\n            openChat(pendingChatId);\n            localStorage.removeItem('pendingChatRequest');\n          }\n        });\n      }\n\n      // Set up polling interval - MUCH less frequent to prevent flooding\n      const intervalId = setInterval(() => {\n        // Poll for notifications and active chats\n        fetchNotifications();\n\n        // If we have a current chat open, fetch its messages too\n        if (currentChat) {\n          fetchMessages(currentChat.id);\n        } else {\n          // Only poll for active chats if we don't have an open chat\n          fetchActiveChats();\n        }\n      }, 10000); // Poll every 10 seconds instead of flooding\n\n      return () => clearInterval(intervalId);\n    }\n  }, [user, currentChat, fetchNotifications, fetchActiveChats, fetchMessages, openChat]);\n  return /*#__PURE__*/_jsxDEV(ChatContext.Provider, {\n    value: {\n      activeChats,\n      notifications,\n      currentChat,\n      messages,\n      loading,\n      error,\n      sendChatRequest,\n      acceptChatRequest,\n      declineChatRequest,\n      sendMessage,\n      fetchMessages,\n      openChat,\n      closeChat,\n      fetchActiveChats,\n      fetchNotifications\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 384,\n    columnNumber: 5\n  }, this);\n};\n_s(ChatProvider, \"TCxRVNoXe9v9197iU9hJ2PoIKAQ=\");\n_c = ChatProvider;\nexport default ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","useCallback","useRef","api","AuthContext","jsxDEV","_jsxDEV","ChatContext","ChatProvider","children","_s","user","activeChats","setActiveChats","notifications","setNotifications","currentChat","setCurrentChat","messages","setMessages","loading","setLoading","error","setError","lastRequest","chat","pendingRequests","enforceApiDelay","requestType","minDelay","current","console","log","now","Date","fetchNotifications","force","response","get","newNotifications","data","JSON","stringify","fetchActiveChats","newChats","chats","sendChatRequest","recipientId","post","localStorage","setItem","chatRoomId","_error$response","_error$response$data","message","acceptChatRequest","updatedChats","acceptedChat","find","c","id","fetchMessages","setTimeout","retryChats","retryChat","declineChatRequest","toISOString","Promise","resolve","sendMessage","newMessage","chatMessage","prev","profiles","username","openChat","closeChat","pendingChatId","getItem","then","pendingChat","hasJoined","removeItem","intervalId","setInterval","clearInterval","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/anubhav/project_6/auth-system/frontend/src/context/ChatContext.js"],"sourcesContent":["import React, { createContext, useState, useEffect, useContext, useCallback, useRef } from 'react';\nimport api from '../utils/api';\nimport { AuthContext } from './AuthContext';\n\nexport const ChatContext = createContext();\n\nexport const ChatProvider = ({ children }) => {\n  const { user } = useContext(AuthContext);\n  const [activeChats, setActiveChats] = useState([]);\n  const [notifications, setNotifications] = useState([]);\n  const [currentChat, setCurrentChat] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  // Add these to track last request times\n  const lastRequest = useRef({\n    chat: 0,\n    notifications: 0,\n    messages: 0\n  });\n  \n  // Add this to prevent concurrent requests\n  const pendingRequests = useRef({\n    chat: false,\n    notifications: false,\n    messages: false\n  });\n\n  // Add the missing enforceApiDelay function\n  const enforceApiDelay = useCallback(async (requestType, minDelay = 2000) => {\n    if (pendingRequests.current[requestType]) {\n      console.log(`${requestType} request already in progress, skipping`);\n      return false;\n    }\n    \n    const now = Date.now();\n    if (now - lastRequest.current[requestType] < minDelay) {\n      console.log(`Throttling ${requestType} request, too soon`);\n      return false;\n    }\n    \n    pendingRequests.current[requestType] = true;\n    lastRequest.current[requestType] = now;\n    return true;\n  }, []);\n\n  // Throttled fetch notifications\n  const fetchNotifications = useCallback(async (force = false) => {\n    if (!user) return [];\n    \n    // Don't allow concurrent requests\n    if (pendingRequests.current.notifications) {\n      console.log('Notification request already in progress, skipping');\n      return notifications;\n    }\n    \n    const now = Date.now();\n    // Only fetch if it's been more than 10 seconds since last check or forced\n    if (!force && now - lastRequest.current.notifications < 10000) {\n      return notifications; // Return cached notifications\n\n    }\n    \n    try {\n      pendingRequests.current.notifications = true;\n      console.log('Fetching notifications...');\n      const response = await api.get('/chat/notifications');\n      lastRequest.current.notifications = now;\n      \n      // Only update state if the notifications have changed\n      const newNotifications = response.data.notifications || [];\n      if (JSON.stringify(newNotifications) !== JSON.stringify(notifications)) {\n        setNotifications(newNotifications);\n      }\n      \n      return newNotifications;\n    } catch (error) {\n      console.error('Error fetching notifications:', error);\n      return [];\n    } finally {\n      pendingRequests.current.notifications = false;\n    }\n  }, [user, notifications]);\n\n  // Throttled fetch active chats\n  const fetchActiveChats = useCallback(async (force = false) => {\n    if (!user) return [];\n    \n    // Don't allow concurrent requests\n    if (pendingRequests.current.chat) {\n      console.log('Chat request already in progress, skipping');\n      return activeChats;\n    }\n    \n    const now = Date.now();\n    // Only fetch if it's been more than 10 seconds since last check or forced\n    if (!force && now - lastRequest.current.chat < 10000) {\n      return activeChats; // Return cached chats\n    }\n    \n    try {\n      pendingRequests.current.chat = true;\n      setLoading(true);\n\n      console.log('Fetching active chats...');\n      const response = await api.get('/chat/active');\n      lastRequest.current.chat = now;\n      \n      const newChats = response.data.chats || [];\n      \n      // Only update state if the chats have changed\n      if (JSON.stringify(newChats) !== JSON.stringify(activeChats)) {\n        console.log('Updating active chats, found changes');\n        setActiveChats(newChats);\n      } else {\n        console.log('No changes in active chats');\n      }\n      \n      return newChats;\n\n    } catch (error) {\n      console.error('Error fetching active chats:', error);\n      setError('Failed to fetch active chats');\n      return [];\n    } finally {\n      setLoading(false);\n\n      pendingRequests.current.chat = false;\n\n    }\n  }, [user, activeChats]);\n\n  // Send a chat request to another user\n  const sendChatRequest = async (recipientId) => {\n    if (!user || !recipientId) return;\n    \n    try {\n      setLoading(true);\n      console.log('Sending chat request to:', recipientId);\n      const response = await api.post('/chat/request', { recipientId });\n      \n      // Force refresh active chats\n\n      await fetchActiveChats(true);\n      \n      // Store the chat request ID for monitoring\n      localStorage.setItem('pendingChatRequest', response.data.chatRoomId);\n      \n      return response.data;\n    } catch (error) {\n      console.error('Error sending chat request:', error);\n      setError('Failed to send chat request: ' + (error.response?.data?.message || error.message));\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n\n  // Accept a chat request\n\n  const acceptChatRequest = async (chatRoomId) => {\n    if (!user || !chatRoomId) return;\n    \n    try {\n      setLoading(true);\n      console.log('Accepting chat request:', chatRoomId);\n\n      \n      const response = await api.post('/chat/accept', { chatRoomId });\n      console.log('Accept response:', response.data);\n      \n\n      // Force refresh notifications and active chats\n\n      await fetchNotifications(true);\n      const updatedChats = await fetchActiveChats(true);\n      \n      console.log('Looking for chat room in active chats');\n      const acceptedChat = updatedChats.find(c => c.id === chatRoomId);\n      \n      if (acceptedChat) {\n        console.log('Found accepted chat, opening it:', acceptedChat);\n        setCurrentChat(acceptedChat);\n        \n        // Fetch messages for this chat\n        await fetchMessages(chatRoomId);\n      } else {\n        console.error('Accepted chat not found in active chats. Will retry...');\n        // Retry once after a delay\n\n        setTimeout(async () => {\n          const retryChats = await fetchActiveChats(true);\n          const retryChat = retryChats.find(c => c.id === chatRoomId);\n          if (retryChat) {\n            console.log('Found chat on retry');\n            setCurrentChat(retryChat);\n\n            await fetchMessages(chatRoomId);\n\n          }\n        }, 2000);\n      }\n      \n      return response.data;\n    } catch (error) {\n      console.error('Error accepting chat request:', error);\n      setError('Failed to accept chat request: ' + (error.message || 'Unknown error'));\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n\n  // Decline a chat request\n\n  const declineChatRequest = async (chatRoomId) => {\n    if (!user || !chatRoomId) return;\n    \n    try {\n      setLoading(true);\n      console.log(`[${new Date().toISOString()}] Declining chat request: ${chatRoomId}...`);\n      \n      // Add artificial delay of 1 second\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      \n      const response = await api.post('/chat/decline', { chatRoomId });\n      \n      // Force refresh notifications\n\n      await fetchNotifications(true);\n      \n      return response.data;\n    } catch (error) {\n      console.error('Error declining chat request:', error);\n      setError('Failed to decline chat request');\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Send a message in a chat with enhanced error handling\n  const sendMessage = async (chatRoomId, message) => {\n    if (!user || !chatRoomId || !message) return;\n    \n    try {\n      console.log('Sending message to room:', chatRoomId);\n\n      const response = await api.post('/chat/send', { chatRoomId, message });\n      \n      // Add the new message to the state\n      const newMessage = response.data.chatMessage;\n      setMessages(prev => [\n        ...prev, \n        {...newMessage, profiles: { username: user.username }}\n      ]);\n      \n      return response.data;\n    } catch (error) {\n      console.error('Error sending message:', error);\n      setError('Failed to send message: ' + error.message);\n      throw error;\n    }\n  };\n\n  // Fetch messages for a chat with better error handling and throttling\n  const fetchMessages = useCallback(async (chatRoomId, force = false) => {\n    if (!user || !chatRoomId) return;\n    \n    // If we already have an active chat and it's not forced, enforce delay\n    if (currentChat && !force && !(await enforceApiDelay('messages'))) {\n      return messages; // Return cached messages\n    }\n    \n    try {\n      setLoading(true);\n\n      console.log('Fetching messages for room:', chatRoomId);\n      const response = await api.get(`/chat/messages/${chatRoomId}`);\n      \n      setMessages(response.data.messages || []);\n      return response.data.messages;\n\n    } catch (error) {\n      console.error('Error fetching messages:', error);\n      setError('Failed to fetch messages: ' + error.message);\n      setMessages([]);\n      return [];\n    } finally {\n      setLoading(false);\n      pendingRequests.current.messages = false;\n    }\n  }, [user, messages, currentChat, enforceApiDelay]);\n\n\n  // Open a chat\n  const openChat = useCallback(async (chatRoomId) => {\n    try {\n      console.log('Opening chat:', chatRoomId);\n\n      \n      // First check if this chat is in our current active chats\n      let chat = activeChats.find(c => c.id === chatRoomId);\n      \n\n      // If not found, try fetching fresh data\n\n      if (!chat) {\n        console.log('Chat not found in current state, fetching fresh data');\n        const updatedChats = await fetchActiveChats(true);\n        chat = updatedChats.find(c => c.id === chatRoomId);\n      }\n      \n      if (chat) {\n        console.log('Setting current chat:', chat);\n        setCurrentChat(chat);\n\n        await fetchMessages(chatRoomId);\n      } else {\n        console.error('Chat not found in active chats');\n        setError('Chat not found');\n\n      }\n    } catch (error) {\n      console.error('Error opening chat:', error);\n      setError('Failed to open chat: ' + error.message);\n    }\n  }, [activeChats, fetchActiveChats, fetchMessages]);\n\n  // Close the current chat\n  const closeChat = () => {\n    setCurrentChat(null);\n    setMessages([]);\n  };\n  \n\n  // Set up polling at a reasonable rate (once per 10 seconds)\n  useEffect(() => {\n    if (user) {\n      // Initial load\n      fetchNotifications(true);\n      fetchActiveChats(true);\n      \n      // Check for any pending chat requests\n\n      const pendingChatId = localStorage.getItem('pendingChatRequest');\n      if (pendingChatId) {\n        console.log('Found pending chat request, checking status:', pendingChatId);\n        fetchActiveChats(true).then(chats => {\n          const pendingChat = chats.find(c => c.id === pendingChatId);\n          if (pendingChat && pendingChat.hasJoined) {\n            console.log('Pending chat has been accepted, opening');\n            openChat(pendingChatId);\n            localStorage.removeItem('pendingChatRequest');\n          }\n        });\n      }\n      \n\n\n      // Set up polling interval - MUCH less frequent to prevent flooding\n      const intervalId = setInterval(() => {\n        // Poll for notifications and active chats\n        fetchNotifications();\n        \n        // If we have a current chat open, fetch its messages too\n        if (currentChat) {\n          fetchMessages(currentChat.id);\n        } else {\n          // Only poll for active chats if we don't have an open chat\n          fetchActiveChats();\n        }\n      }, 10000); // Poll every 10 seconds instead of flooding\n      \n      return () => clearInterval(intervalId);\n    }\n  }, [user, currentChat, fetchNotifications, fetchActiveChats, fetchMessages, openChat]);\n  \n\n  return (\n    <ChatContext.Provider\n      value={{\n        activeChats,\n        notifications,\n        currentChat,\n        messages,\n        loading,\n        error,\n        sendChatRequest,\n        acceptChatRequest,\n        declineChatRequest,\n        sendMessage,\n        fetchMessages,\n        openChat,\n        closeChat,\n        fetchActiveChats,\n        fetchNotifications\n      }}\n    >\n      {children}\n    </ChatContext.Provider>\n  );\n};\n\nexport default ChatProvider;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}