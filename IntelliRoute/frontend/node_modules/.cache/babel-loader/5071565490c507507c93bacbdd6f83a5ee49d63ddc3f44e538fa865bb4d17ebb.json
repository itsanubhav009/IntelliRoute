{"ast":null,"code":"var _jsxFileName = \"/home/anubhav/project_6/auth-system/frontend/src/context/ChatContext.js\",\n  _s = $RefreshSig$();\nimport React, { createContext, useState, useEffect, useContext, useCallback } from 'react';\nimport api from '../utils/api';\nimport { AuthContext } from './AuthContext';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const ChatContext = /*#__PURE__*/createContext();\nexport const ChatProvider = ({\n  children\n}) => {\n  _s();\n  const {\n    user\n  } = useContext(AuthContext);\n  const [activeChats, setActiveChats] = useState([]);\n  const [notifications, setNotifications] = useState([]);\n  const [currentChat, setCurrentChat] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [pollingInterval, setPollingInterval] = useState(null);\n  const [lastNotificationCheck, setLastNotificationCheck] = useState(0);\n  const [lastChatUpdate, setLastChatUpdate] = useState(0);\n\n  // Debounced fetch notifications - prevents excessive refreshing\n  const fetchNotifications = useCallback(async (force = false) => {\n    if (!user) return [];\n    const now = Date.now();\n    // Only fetch if it's been more than 5 seconds since last check or forced\n    if (!force && now - lastNotificationCheck < 5000) {\n      return notifications; // Return cached notifications\n    }\n    try {\n      console.log('Fetching notifications...');\n      const response = await api.get('/chat/notifications');\n      setLastNotificationCheck(now);\n\n      // Only update state if the notifications have changed\n      if (JSON.stringify(response.data.notifications) !== JSON.stringify(notifications)) {\n        setNotifications(response.data.notifications || []);\n      }\n      return response.data.notifications || [];\n    } catch (error) {\n      console.error('Error fetching notifications:', error);\n      return [];\n    }\n  }, [user, lastNotificationCheck, notifications]);\n\n  // Optimized fetch active chats\n  const fetchActiveChats = useCallback(async (force = false) => {\n    if (!user) return [];\n    const now = Date.now();\n    // Only fetch if it's been more than 10 seconds since last check or forced\n    if (!force && now - lastChatUpdate < 10000) {\n      return activeChats; // Return cached chats\n    }\n    try {\n      setLoading(true);\n      const response = await api.get('/chat/active');\n      setLastChatUpdate(now);\n\n      // Only update state if the chats have changed\n      if (JSON.stringify(response.data.chats) !== JSON.stringify(activeChats)) {\n        setActiveChats(response.data.chats || []);\n      }\n      return response.data.chats || [];\n    } catch (error) {\n      console.error('Error fetching active chats:', error);\n      setError('Failed to fetch active chats');\n      return [];\n    } finally {\n      setLoading(false);\n    }\n  }, [user, lastChatUpdate, activeChats]);\n\n  // Send a chat request to another user\n  const sendChatRequest = async recipientId => {\n    if (!user || !recipientId) return;\n    try {\n      setLoading(true);\n      console.log('Sending chat request to:', recipientId);\n      const response = await api.post('/chat/request', {\n        recipientId\n      });\n\n      // Force refresh active chats\n      await fetchActiveChats(true);\n\n      // Store the chat request ID for monitoring\n      localStorage.setItem('pendingChatRequest', response.data.chatRoomId);\n      return response.data;\n    } catch (error) {\n      var _error$response, _error$response$data;\n      console.error('Error sending chat request:', error);\n      setError('Failed to send chat request: ' + (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || error.message));\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Accept a chat request with improved error handling\n  const acceptChatRequest = async chatRoomId => {\n    if (!user || !chatRoomId) return;\n    try {\n      setLoading(true);\n      console.log('Accepting chat request:', chatRoomId);\n      const response = await api.post('/chat/accept', {\n        chatRoomId\n      });\n      console.log('Accept response:', response.data);\n\n      // Force refresh notifications and active chats\n      await fetchNotifications(true);\n      const updatedChats = await fetchActiveChats(true);\n      console.log('Looking for chat room in active chats');\n      const acceptedChat = updatedChats.find(c => c.id === chatRoomId);\n      if (acceptedChat) {\n        console.log('Found accepted chat:', acceptedChat);\n        setCurrentChat(acceptedChat);\n\n        // Fetch messages for this chat\n        await fetchMessages(chatRoomId);\n      } else {\n        console.error('Accepted chat not found in active chats. Will retry...');\n        // Retry after a delay\n        setTimeout(async () => {\n          const retryChats = await fetchActiveChats(true);\n          const retryChat = retryChats.find(c => c.id === chatRoomId);\n          if (retryChat) {\n            console.log('Found chat on retry');\n            setCurrentChat(retryChat);\n            await fetchMessages(chatRoomId);\n          }\n        }, 1000);\n      }\n      return response.data;\n    } catch (error) {\n      console.error('Error accepting chat request:', error);\n      setError('Failed to accept chat request: ' + (error.message || 'Unknown error'));\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Decline a chat request \n  const declineChatRequest = async chatRoomId => {\n    if (!user || !chatRoomId) return;\n    try {\n      setLoading(true);\n      const response = await api.post('/chat/decline', {\n        chatRoomId\n      });\n\n      // Force refresh notifications\n      await fetchNotifications(true);\n      return response.data;\n    } catch (error) {\n      console.error('Error declining chat request:', error);\n      setError('Failed to decline chat request');\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Send a message in a chat with enhanced error handling\n  const sendMessage = async (chatRoomId, message) => {\n    if (!user || !chatRoomId || !message) return;\n    try {\n      console.log('Sending message to room:', chatRoomId);\n      const response = await api.post('/chat/send', {\n        chatRoomId,\n        message\n      });\n\n      // Add the new message to the state\n      const newMessage = response.data.chatMessage;\n      setMessages(prev => [...prev, {\n        ...newMessage,\n        profiles: {\n          username: user.username\n        }\n      }]);\n      return response.data;\n    } catch (error) {\n      console.error('Error sending message:', error);\n      setError('Failed to send message: ' + error.message);\n      throw error;\n    }\n  };\n\n  // Fetch messages for a chat with better error handling\n  const fetchMessages = async chatRoomId => {\n    if (!user || !chatRoomId) return;\n    try {\n      setLoading(true);\n      console.log('Fetching messages for room:', chatRoomId);\n      const response = await api.get(`/chat/messages/${chatRoomId}`);\n      if (response.data && Array.isArray(response.data.messages)) {\n        console.log(`Fetched ${response.data.messages.length} messages`);\n        setMessages(response.data.messages || []);\n        return response.data.messages;\n      } else {\n        console.error('Invalid messages response:', response.data);\n        setMessages([]);\n        return [];\n      }\n    } catch (error) {\n      console.error('Error fetching messages:', error);\n      setError('Failed to fetch messages: ' + error.message);\n      setMessages([]);\n      return [];\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Open a chat with improved robustness\n  const openChat = async chatRoomId => {\n    try {\n      console.log('Opening chat:', chatRoomId);\n\n      // First check if this chat is in our current active chats\n      let chat = activeChats.find(c => c.id === chatRoomId);\n\n      // If not found, try fetching fresh data\n      if (!chat) {\n        console.log('Chat not found in current state, fetching fresh data');\n        const updatedChats = await fetchActiveChats(true);\n        chat = updatedChats.find(c => c.id === chatRoomId);\n      }\n      if (chat) {\n        console.log('Setting current chat:', chat);\n        setCurrentChat(chat);\n        await fetchMessages(chatRoomId);\n      } else {\n        console.error('Chat not found in active chats');\n        setError('Chat not found - it may have been deleted or you no longer have access');\n      }\n    } catch (error) {\n      console.error('Error opening chat:', error);\n      setError('Failed to open chat: ' + error.message);\n    }\n  };\n\n  // Close the current chat\n  const closeChat = () => {\n    setCurrentChat(null);\n    setMessages([]);\n  };\n\n  // Setup efficient polling with exponential backoff\n  useEffect(() => {\n    if (user) {\n      // Initial load - force fetch\n      fetchNotifications(true);\n      fetchActiveChats(true);\n\n      // Check for any pending chat requests we sent\n      const pendingChatId = localStorage.getItem('pendingChatRequest');\n      if (pendingChatId) {\n        console.log('Found pending chat request, checking status:', pendingChatId);\n        fetchActiveChats(true).then(chats => {\n          const pendingChat = chats.find(c => c.id === pendingChatId);\n          if (pendingChat && pendingChat.hasJoined) {\n            console.log('Pending chat has been accepted, opening');\n            openChat(pendingChatId);\n            localStorage.removeItem('pendingChatRequest');\n          }\n        });\n      }\n\n      // Set up smarter polling with increasing intervals between checks\n      let pollCount = 0;\n      const maxInterval = 30000; // Max 30 seconds between polls\n      const baseInterval = 5000; // Start with 5 seconds\n\n      const doPoll = async () => {\n        // If user has a current chat, poll more frequently\n        const interval = currentChat ? Math.min(baseInterval, 5000) : Math.min(baseInterval + pollCount * 1000, maxInterval);\n        pollCount++;\n\n        // Check for notifications\n        const newNotifications = await fetchNotifications();\n\n        // If there are chat_accepted notifications, handle them\n        if (newNotifications && newNotifications.length > 0) {\n          const acceptedNotification = newNotifications.find(n => n.type === 'chat_accepted');\n          if (acceptedNotification && !currentChat) {\n            console.log('Found chat_accepted notification:', acceptedNotification);\n            openChat(acceptedNotification.chat_room_id);\n          }\n        }\n\n        // If there's an active chat, refresh messages\n        if (currentChat) {\n          fetchMessages(currentChat.id);\n          // Reset poll count to keep checks frequent during active chats\n          pollCount = 0;\n        }\n\n        // Schedule next poll\n        return setTimeout(doPoll, interval);\n      };\n      const timeoutId = doPoll();\n      return () => clearTimeout(timeoutId);\n    }\n  }, [user, currentChat]);\n  return /*#__PURE__*/_jsxDEV(ChatContext.Provider, {\n    value: {\n      activeChats,\n      notifications,\n      currentChat,\n      messages,\n      loading,\n      error,\n      sendChatRequest,\n      acceptChatRequest,\n      declineChatRequest,\n      sendMessage,\n      fetchMessages,\n      openChat,\n      closeChat,\n      fetchActiveChats,\n      fetchNotifications\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 320,\n    columnNumber: 5\n  }, this);\n};\n_s(ChatProvider, \"FM/wc+dgis4HoQquWZGiFOabbgk=\");\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","useCallback","api","AuthContext","jsxDEV","_jsxDEV","ChatContext","ChatProvider","children","_s","user","activeChats","setActiveChats","notifications","setNotifications","currentChat","setCurrentChat","messages","setMessages","loading","setLoading","error","setError","pollingInterval","setPollingInterval","lastNotificationCheck","setLastNotificationCheck","lastChatUpdate","setLastChatUpdate","fetchNotifications","force","now","Date","console","log","response","get","JSON","stringify","data","fetchActiveChats","chats","sendChatRequest","recipientId","post","localStorage","setItem","chatRoomId","_error$response","_error$response$data","message","acceptChatRequest","updatedChats","acceptedChat","find","c","id","fetchMessages","setTimeout","retryChats","retryChat","declineChatRequest","sendMessage","newMessage","chatMessage","prev","profiles","username","Array","isArray","length","openChat","chat","closeChat","pendingChatId","getItem","then","pendingChat","hasJoined","removeItem","pollCount","maxInterval","baseInterval","doPoll","interval","Math","min","newNotifications","acceptedNotification","n","type","chat_room_id","timeoutId","clearTimeout","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/anubhav/project_6/auth-system/frontend/src/context/ChatContext.js"],"sourcesContent":["import React, { createContext, useState, useEffect, useContext, useCallback } from 'react';\nimport api from '../utils/api';\nimport { AuthContext } from './AuthContext';\n\nexport const ChatContext = createContext();\n\nexport const ChatProvider = ({ children }) => {\n  const { user } = useContext(AuthContext);\n  const [activeChats, setActiveChats] = useState([]);\n  const [notifications, setNotifications] = useState([]);\n  const [currentChat, setCurrentChat] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [pollingInterval, setPollingInterval] = useState(null);\n  const [lastNotificationCheck, setLastNotificationCheck] = useState(0);\n  const [lastChatUpdate, setLastChatUpdate] = useState(0);\n\n  // Debounced fetch notifications - prevents excessive refreshing\n  const fetchNotifications = useCallback(async (force = false) => {\n    if (!user) return [];\n    \n    const now = Date.now();\n    // Only fetch if it's been more than 5 seconds since last check or forced\n    if (!force && now - lastNotificationCheck < 5000) {\n      return notifications; // Return cached notifications\n    }\n    \n    try {\n      console.log('Fetching notifications...');\n      const response = await api.get('/chat/notifications');\n      setLastNotificationCheck(now);\n      \n      // Only update state if the notifications have changed\n      if (JSON.stringify(response.data.notifications) !== JSON.stringify(notifications)) {\n        setNotifications(response.data.notifications || []);\n      }\n      \n      return response.data.notifications || [];\n    } catch (error) {\n      console.error('Error fetching notifications:', error);\n      return [];\n    }\n  }, [user, lastNotificationCheck, notifications]);\n\n  // Optimized fetch active chats\n  const fetchActiveChats = useCallback(async (force = false) => {\n    if (!user) return [];\n    \n    const now = Date.now();\n    // Only fetch if it's been more than 10 seconds since last check or forced\n    if (!force && now - lastChatUpdate < 10000) {\n      return activeChats; // Return cached chats\n    }\n    \n    try {\n      setLoading(true);\n      const response = await api.get('/chat/active');\n      setLastChatUpdate(now);\n      \n      // Only update state if the chats have changed\n      if (JSON.stringify(response.data.chats) !== JSON.stringify(activeChats)) {\n        setActiveChats(response.data.chats || []);\n      }\n      \n      return response.data.chats || [];\n    } catch (error) {\n      console.error('Error fetching active chats:', error);\n      setError('Failed to fetch active chats');\n      return [];\n    } finally {\n      setLoading(false);\n    }\n  }, [user, lastChatUpdate, activeChats]);\n\n  // Send a chat request to another user\n  const sendChatRequest = async (recipientId) => {\n    if (!user || !recipientId) return;\n    \n    try {\n      setLoading(true);\n      console.log('Sending chat request to:', recipientId);\n      const response = await api.post('/chat/request', { recipientId });\n      \n      // Force refresh active chats\n      await fetchActiveChats(true);\n      \n      // Store the chat request ID for monitoring\n      localStorage.setItem('pendingChatRequest', response.data.chatRoomId);\n      \n      return response.data;\n    } catch (error) {\n      console.error('Error sending chat request:', error);\n      setError('Failed to send chat request: ' + (error.response?.data?.message || error.message));\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Accept a chat request with improved error handling\n  const acceptChatRequest = async (chatRoomId) => {\n    if (!user || !chatRoomId) return;\n    \n    try {\n      setLoading(true);\n      console.log('Accepting chat request:', chatRoomId);\n      \n      const response = await api.post('/chat/accept', { chatRoomId });\n      console.log('Accept response:', response.data);\n      \n      // Force refresh notifications and active chats\n      await fetchNotifications(true);\n      const updatedChats = await fetchActiveChats(true);\n      \n      console.log('Looking for chat room in active chats');\n      const acceptedChat = updatedChats.find(c => c.id === chatRoomId);\n      \n      if (acceptedChat) {\n        console.log('Found accepted chat:', acceptedChat);\n        setCurrentChat(acceptedChat);\n        \n        // Fetch messages for this chat\n        await fetchMessages(chatRoomId);\n      } else {\n        console.error('Accepted chat not found in active chats. Will retry...');\n        // Retry after a delay\n        setTimeout(async () => {\n          const retryChats = await fetchActiveChats(true);\n          const retryChat = retryChats.find(c => c.id === chatRoomId);\n          if (retryChat) {\n            console.log('Found chat on retry');\n            setCurrentChat(retryChat);\n            await fetchMessages(chatRoomId);\n          }\n        }, 1000);\n      }\n      \n      return response.data;\n    } catch (error) {\n      console.error('Error accepting chat request:', error);\n      setError('Failed to accept chat request: ' + (error.message || 'Unknown error'));\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Decline a chat request \n  const declineChatRequest = async (chatRoomId) => {\n    if (!user || !chatRoomId) return;\n    \n    try {\n      setLoading(true);\n      const response = await api.post('/chat/decline', { chatRoomId });\n      \n      // Force refresh notifications\n      await fetchNotifications(true);\n      \n      return response.data;\n    } catch (error) {\n      console.error('Error declining chat request:', error);\n      setError('Failed to decline chat request');\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Send a message in a chat with enhanced error handling\n  const sendMessage = async (chatRoomId, message) => {\n    if (!user || !chatRoomId || !message) return;\n    \n    try {\n      console.log('Sending message to room:', chatRoomId);\n      const response = await api.post('/chat/send', { chatRoomId, message });\n      \n      // Add the new message to the state\n      const newMessage = response.data.chatMessage;\n      setMessages(prev => [\n        ...prev, \n        {...newMessage, profiles: { username: user.username }}\n      ]);\n      \n      return response.data;\n    } catch (error) {\n      console.error('Error sending message:', error);\n      setError('Failed to send message: ' + error.message);\n      throw error;\n    }\n  };\n\n  // Fetch messages for a chat with better error handling\n  const fetchMessages = async (chatRoomId) => {\n    if (!user || !chatRoomId) return;\n    \n    try {\n      setLoading(true);\n      console.log('Fetching messages for room:', chatRoomId);\n      const response = await api.get(`/chat/messages/${chatRoomId}`);\n      \n      if (response.data && Array.isArray(response.data.messages)) {\n        console.log(`Fetched ${response.data.messages.length} messages`);\n        setMessages(response.data.messages || []);\n        return response.data.messages;\n      } else {\n        console.error('Invalid messages response:', response.data);\n        setMessages([]);\n        return [];\n      }\n    } catch (error) {\n      console.error('Error fetching messages:', error);\n      setError('Failed to fetch messages: ' + error.message);\n      setMessages([]);\n      return [];\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Open a chat with improved robustness\n  const openChat = async (chatRoomId) => {\n    try {\n      console.log('Opening chat:', chatRoomId);\n      \n      // First check if this chat is in our current active chats\n      let chat = activeChats.find(c => c.id === chatRoomId);\n      \n      // If not found, try fetching fresh data\n      if (!chat) {\n        console.log('Chat not found in current state, fetching fresh data');\n        const updatedChats = await fetchActiveChats(true);\n        chat = updatedChats.find(c => c.id === chatRoomId);\n      }\n      \n      if (chat) {\n        console.log('Setting current chat:', chat);\n        setCurrentChat(chat);\n        await fetchMessages(chatRoomId);\n      } else {\n        console.error('Chat not found in active chats');\n        setError('Chat not found - it may have been deleted or you no longer have access');\n      }\n    } catch (error) {\n      console.error('Error opening chat:', error);\n      setError('Failed to open chat: ' + error.message);\n    }\n  };\n\n  // Close the current chat\n  const closeChat = () => {\n    setCurrentChat(null);\n    setMessages([]);\n  };\n  \n  // Setup efficient polling with exponential backoff\n  useEffect(() => {\n    if (user) {\n      // Initial load - force fetch\n      fetchNotifications(true);\n      fetchActiveChats(true);\n      \n      // Check for any pending chat requests we sent\n      const pendingChatId = localStorage.getItem('pendingChatRequest');\n      if (pendingChatId) {\n        console.log('Found pending chat request, checking status:', pendingChatId);\n        fetchActiveChats(true).then(chats => {\n          const pendingChat = chats.find(c => c.id === pendingChatId);\n          if (pendingChat && pendingChat.hasJoined) {\n            console.log('Pending chat has been accepted, opening');\n            openChat(pendingChatId);\n            localStorage.removeItem('pendingChatRequest');\n          }\n        });\n      }\n      \n      // Set up smarter polling with increasing intervals between checks\n      let pollCount = 0;\n      const maxInterval = 30000; // Max 30 seconds between polls\n      const baseInterval = 5000; // Start with 5 seconds\n      \n      const doPoll = async () => {\n        // If user has a current chat, poll more frequently\n        const interval = currentChat \n          ? Math.min(baseInterval, 5000) \n          : Math.min(baseInterval + (pollCount * 1000), maxInterval);\n        \n        pollCount++;\n        \n        // Check for notifications\n        const newNotifications = await fetchNotifications();\n        \n        // If there are chat_accepted notifications, handle them\n        if (newNotifications && newNotifications.length > 0) {\n          const acceptedNotification = newNotifications.find(n => n.type === 'chat_accepted');\n          if (acceptedNotification && !currentChat) {\n            console.log('Found chat_accepted notification:', acceptedNotification);\n            openChat(acceptedNotification.chat_room_id);\n          }\n        }\n        \n        // If there's an active chat, refresh messages\n        if (currentChat) {\n          fetchMessages(currentChat.id);\n          // Reset poll count to keep checks frequent during active chats\n          pollCount = 0;\n        }\n        \n        // Schedule next poll\n        return setTimeout(doPoll, interval);\n      };\n      \n      const timeoutId = doPoll();\n      \n      return () => clearTimeout(timeoutId);\n    }\n  }, [user, currentChat]);\n\n  return (\n    <ChatContext.Provider\n      value={{\n        activeChats,\n        notifications,\n        currentChat,\n        messages,\n        loading,\n        error,\n        sendChatRequest,\n        acceptChatRequest,\n        declineChatRequest,\n        sendMessage,\n        fetchMessages,\n        openChat,\n        closeChat,\n        fetchActiveChats,\n        fetchNotifications\n      }}\n    >\n      {children}\n    </ChatContext.Provider>\n  );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}