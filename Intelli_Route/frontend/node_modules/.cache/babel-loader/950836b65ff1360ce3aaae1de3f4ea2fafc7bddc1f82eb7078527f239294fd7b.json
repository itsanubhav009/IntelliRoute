{"ast":null,"code":"var _jsxFileName = \"/home/anubhav/project_6/auth-system/frontend/src/context/ChatContext.js\",\n  _s = $RefreshSig$();\nimport React, { createContext, useState, useEffect, useContext, useCallback, useRef } from 'react';\nimport api from '../utils/api';\nimport { AuthContext } from './AuthContext';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const ChatContext = /*#__PURE__*/createContext();\nexport const ChatProvider = ({\n  children\n}) => {\n  _s();\n  const {\n    user\n  } = useContext(AuthContext);\n  const [activeChats, setActiveChats] = useState([]);\n  const [notifications, setNotifications] = useState([]);\n  const [currentChat, setCurrentChat] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [chatStatus, setChatStatus] = useState(null);\n\n  // Add these to track last request times\n  const lastRequest = useRef({\n    chat: 0,\n    notifications: 0,\n    messages: 0\n  });\n\n  // Add this to prevent concurrent requests\n  const pendingRequests = useRef({\n    chat: false,\n    notifications: false,\n    messages: false\n  });\n\n  // Enforce API delay function\n  const enforceApiDelay = useCallback(async (requestType, minDelay = 2000) => {\n    if (pendingRequests.current[requestType]) {\n      console.log(`${requestType} request already in progress, skipping`);\n      return false;\n    }\n    const now = Date.now();\n    if (now - lastRequest.current[requestType] < minDelay) {\n      console.log(`Throttling ${requestType} request, too soon`);\n      return false;\n    }\n    pendingRequests.current[requestType] = true;\n    lastRequest.current[requestType] = now;\n    return true;\n  }, []);\n\n  // Throttled fetch notifications\n  const fetchNotifications = useCallback(async (force = false) => {\n    if (!user) return [];\n    if (pendingRequests.current.notifications) {\n      return notifications;\n    }\n    const now = Date.now();\n    if (!force && now - lastRequest.current.notifications < 10000) {\n      return notifications;\n    }\n    try {\n      pendingRequests.current.notifications = true;\n      const response = await api.get('/chat/notifications');\n      lastRequest.current.notifications = now;\n      const newNotifications = response.data.notifications || [];\n      if (JSON.stringify(newNotifications) !== JSON.stringify(notifications)) {\n        setNotifications(newNotifications);\n      }\n      return newNotifications;\n    } catch (error) {\n      console.error('Error fetching notifications:', error);\n      return [];\n    } finally {\n      pendingRequests.current.notifications = false;\n    }\n  }, [user, notifications]);\n\n  // Throttled fetch active chats\n  const fetchActiveChats = useCallback(async (force = false) => {\n    if (!user) return [];\n    if (pendingRequests.current.chat) {\n      return activeChats;\n    }\n    const now = Date.now();\n    if (!force && now - lastRequest.current.chat < 10000) {\n      return activeChats;\n    }\n    try {\n      pendingRequests.current.chat = true;\n      setLoading(true);\n      const response = await api.get('/chat/active');\n      lastRequest.current.chat = now;\n      const newChats = response.data.chats || [];\n      if (JSON.stringify(newChats) !== JSON.stringify(activeChats)) {\n        setActiveChats(newChats);\n      }\n      return newChats;\n    } catch (error) {\n      console.error('Error fetching active chats:', error);\n      setError('Failed to fetch active chats');\n      return [];\n    } finally {\n      setLoading(false);\n      pendingRequests.current.chat = false;\n    }\n  }, [user, activeChats]);\n\n  // Send a chat request to another user\n  const sendChatRequest = async recipientId => {\n    if (!user || !recipientId) return;\n    try {\n      setLoading(true);\n      setChatStatus({\n        type: 'sending',\n        message: 'Sending chat request...'\n      });\n      const response = await api.post('/chat/request', {\n        recipientId\n      });\n      await fetchActiveChats(true);\n      localStorage.setItem('pendingChatRequest', response.data.chatRoomId);\n      setChatStatus({\n        type: 'success',\n        message: 'Chat request sent successfully! Waiting for acceptance.'\n      });\n      setTimeout(() => setChatStatus(null), 3000);\n      return response.data;\n    } catch (error) {\n      var _error$response, _error$response$data;\n      console.error('Error sending chat request:', error);\n      setChatStatus({\n        type: 'error',\n        message: 'Failed to send chat request: ' + (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.message) || error.message)\n      });\n      setTimeout(() => setChatStatus(null), 5000);\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Accept a chat request with enhanced error handling\n  // Replace the acceptChatRequest function in your ChatContext.js file with this improved version\n  // Add this helper function to your ChatContext.js\n  const ensureParticipantsCanChat = async chatRoomId => {\n    try {\n      console.log(`[${new Date().toISOString()}] Ensuring all participants can chat in room ${chatRoomId}`);\n\n      // Get the chat from active chats\n      const chat = activeChats.find(c => c.id === chatRoomId);\n      if (!chat) {\n        console.error('Chat not found in active chats');\n        return false;\n      }\n\n      // If chat is already active and user has joined, we're good\n      if (chat.isActive && chat.hasJoined) {\n        console.log('Chat is already active and user has joined');\n        return true;\n      }\n\n      // If we need to refresh the chat status\n      const refreshedChats = await fetchActiveChats(true);\n      const refreshedChat = refreshedChats.find(c => c.id === chatRoomId);\n      if (!refreshedChat) {\n        console.error('Chat not found after refresh');\n        return false;\n      }\n      return refreshedChat.isActive && refreshedChat.hasJoined;\n    } catch (error) {\n      console.error('Error ensuring participants can chat:', error);\n      return false;\n    }\n  };\n\n  // Replace the acceptChatRequest function with this improved version\n  const acceptChatRequest = async chatRoomId => {\n    if (!user || !chatRoomId) {\n      console.error('Cannot accept chat: missing user or chatRoomId');\n      return {\n        success: false,\n        error: 'Missing required data'\n      };\n    }\n    try {\n      setLoading(true);\n      setChatStatus({\n        type: 'accepting',\n        message: 'Accepting chat request...'\n      });\n      console.log(`[${new Date().toISOString()}] User ${user.username || 'itsanubhav009'} is accepting chat request ${chatRoomId}`);\n\n      // Make the API call to accept the chat request\n      const response = await api.post('/chat/accept', {\n        chatRoomId\n      });\n      console.log('Accept response from server:', response.data);\n\n      // Force refresh notifications to remove the accepted notification\n      await fetchNotifications(true);\n\n      // Fetch active chats to get the updated chat list\n      const updatedChats = await fetchActiveChats(true);\n      console.log('Updated chats after acceptance:', updatedChats);\n\n      // Find the accepted chat in the updated list\n      let acceptedChat = updatedChats.find(c => c.id === chatRoomId);\n      if (acceptedChat) {\n        console.log('Found accepted chat:', acceptedChat);\n\n        // If chat isn't active yet, we need to wait\n        if (!acceptedChat.isActive || !acceptedChat.hasJoined) {\n          console.log('Chat is not fully active yet. Waiting...');\n          setChatStatus({\n            type: 'waiting',\n            message: 'Waiting for chat room to activate...'\n          });\n\n          // Wait for up to 5 seconds with multiple retries\n          for (let i = 0; i < 5; i++) {\n            // Wait 1 second\n            await new Promise(resolve => setTimeout(resolve, 1000));\n\n            // Refresh the chats again\n            const retryChats = await fetchActiveChats(true);\n            acceptedChat = retryChats.find(c => c.id === chatRoomId);\n            if (acceptedChat && acceptedChat.isActive && acceptedChat.hasJoined) {\n              console.log('Chat is now active!');\n              break;\n            }\n            console.log(`Attempt ${i + 1}: Chat still not fully active`);\n          }\n        }\n\n        // Set as current chat\n        setCurrentChat(acceptedChat);\n\n        // Try to fetch messages\n        try {\n          await fetchMessages(chatRoomId, true);\n        } catch (msgError) {\n          console.warn('Could not fetch messages yet:', msgError);\n        }\n        setChatStatus({\n          type: 'success',\n          message: 'Chat request accepted successfully!'\n        });\n\n        // Clear status after a delay\n        setTimeout(() => {\n          setChatStatus(null);\n        }, 3000);\n        return {\n          success: true,\n          chat: acceptedChat\n        };\n      } else {\n        console.warn('Accepted chat not found in active chats list');\n        setChatStatus({\n          type: 'error',\n          message: 'Could not find the chat after accepting.'\n        });\n        setTimeout(() => {\n          setChatStatus(null);\n        }, 5000);\n        return {\n          success: false,\n          error: 'Chat not found after acceptance'\n        };\n      }\n    } catch (error) {\n      console.error('Error accepting chat request:', error);\n      setChatStatus({\n        type: 'error',\n        message: 'Failed to accept chat request: ' + (error.message || 'Unknown error')\n      });\n      setTimeout(() => {\n        setChatStatus(null);\n      }, 5000);\n      return {\n        success: false,\n        error: error.message || 'Unknown error'\n      };\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Decline a chat request\n  const declineChatRequest = async chatRoomId => {\n    if (!user || !chatRoomId) return;\n    try {\n      setLoading(true);\n      setChatStatus({\n        type: 'declining',\n        message: 'Declining chat request...'\n      });\n      await api.post('/chat/decline', {\n        chatRoomId\n      });\n      await fetchNotifications(true);\n      setChatStatus({\n        type: 'success',\n        message: 'Chat request declined'\n      });\n      setTimeout(() => setChatStatus(null), 3000);\n      return {\n        success: true\n      };\n    } catch (error) {\n      console.error('Error declining chat request:', error);\n      setChatStatus({\n        type: 'error',\n        message: 'Failed to decline chat request: ' + (error.message || 'Unknown error')\n      });\n      setTimeout(() => setChatStatus(null), 5000);\n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Send a message in a chat\n  const sendMessage = async (chatRoomId, message) => {\n    if (!user || !chatRoomId || !message) return;\n    try {\n      const response = await api.post('/chat/send', {\n        chatRoomId,\n        message\n      });\n      const newMessage = response.data.chatMessage;\n      setMessages(prev => [...prev, {\n        ...newMessage,\n        profiles: {\n          username: user.username\n        }\n      }]);\n      return response.data;\n    } catch (error) {\n      var _error$response2, _error$response3, _error$response3$data, _error$response3$data2;\n      console.error('Error sending message:', error);\n      if (((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 403 && (_error$response3 = error.response) !== null && _error$response3 !== void 0 && (_error$response3$data = _error$response3.data) !== null && _error$response3$data !== void 0 && (_error$response3$data2 = _error$response3$data.message) !== null && _error$response3$data2 !== void 0 && _error$response3$data2.includes('not active')) {\n        setChatStatus({\n          type: 'waiting',\n          message: 'Waiting for recipient to accept your chat request...'\n        });\n        setTimeout(() => setChatStatus(null), 5000);\n      } else {\n        setError('Failed to send message: ' + error.message);\n      }\n      throw error;\n    }\n  };\n\n  // Fetch messages for a chat\n  const fetchMessages = useCallback(async (chatRoomId, force = false) => {\n    if (!user || !chatRoomId) return;\n    if (currentChat && !force && !(await enforceApiDelay('messages'))) {\n      return messages;\n    }\n    try {\n      setLoading(true);\n      const response = await api.get(`/chat/messages/${chatRoomId}`);\n      if (response.data.messages) {\n        setMessages(response.data.messages);\n        return response.data.messages;\n      } else {\n        setMessages([]);\n        return [];\n      }\n    } catch (error) {\n      var _error$response4, _error$response5, _error$response5$data, _error$response5$data2;\n      console.error('Error fetching messages:', error);\n      if (((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status) === 403 && (_error$response5 = error.response) !== null && _error$response5 !== void 0 && (_error$response5$data = _error$response5.data) !== null && _error$response5$data !== void 0 && (_error$response5$data2 = _error$response5$data.message) !== null && _error$response5$data2 !== void 0 && _error$response5$data2.includes('not active')) {\n        setChatStatus({\n          type: 'waiting',\n          message: 'This chat room is not active yet. Waiting for acceptance...'\n        });\n        setTimeout(() => setChatStatus(null), 5000);\n        setMessages([]);\n      } else {\n        setError('Failed to fetch messages: ' + error.message);\n        setMessages([]);\n      }\n      return [];\n    } finally {\n      setLoading(false);\n      pendingRequests.current.messages = false;\n    }\n  }, [user, messages, currentChat, enforceApiDelay]);\n\n  // Open a chat with improved error handling for inactive chats\n  const openChat = useCallback(async chatRoomId => {\n    try {\n      setLoading(true);\n      let chat = activeChats.find(c => c.id === chatRoomId);\n      if (!chat) {\n        const updatedChats = await fetchActiveChats(true);\n        chat = updatedChats.find(c => c.id === chatRoomId);\n      }\n      if (chat) {\n        // Check if the chat is active\n        if (!chat.isActive) {\n          // If the chat is not active, check if user has joined\n          if (chat.hasJoined) {\n            // If the user has joined, they're waiting for the other person\n            setChatStatus({\n              type: 'waiting',\n              message: 'Waiting for the other person to accept your chat request...'\n            });\n            setCurrentChat(chat);\n            setMessages([]);\n            setTimeout(() => setChatStatus(null), 5000);\n            return {\n              success: true,\n              chat,\n              status: 'waiting'\n            };\n          } else {\n            // If the user hasn't joined, they need to accept the request first\n            setChatStatus({\n              type: 'pending',\n              message: 'You need to accept this chat request first'\n            });\n            await acceptChatRequest(chatRoomId);\n            return {\n              success: true,\n              chat,\n              status: 'accepted'\n            };\n          }\n        } else {\n          // Chat is active, proceed normally\n          setCurrentChat(chat);\n          await fetchMessages(chatRoomId);\n          return {\n            success: true,\n            chat,\n            status: 'active'\n          };\n        }\n      } else {\n        setChatStatus({\n          type: 'error',\n          message: 'Chat room not found'\n        });\n        setTimeout(() => setChatStatus(null), 5000);\n        return {\n          success: false,\n          error: 'Chat not found'\n        };\n      }\n    } catch (error) {\n      console.error('Error opening chat:', error);\n      setChatStatus({\n        type: 'error',\n        message: 'Failed to open chat: ' + error.message\n      });\n      setTimeout(() => setChatStatus(null), 5000);\n      return {\n        success: false,\n        error: error.message\n      };\n    } finally {\n      setLoading(false);\n    }\n  }, [activeChats, fetchActiveChats, fetchMessages, acceptChatRequest]);\n\n  // Close the current chat\n  const closeChat = () => {\n    setCurrentChat(null);\n    setMessages([]);\n  };\n\n  // Handle notification click\n  const handleNotificationClick = useCallback(async notification => {\n    if (!notification) return;\n    try {\n      // Mark notification as read\n      await api.post('/chat/markNotificationRead', {\n        notificationId: notification.id\n      });\n\n      // If it's a chat request, open the chat (which will handle acceptance if needed)\n      if (notification.type === 'chat_request' || notification.type === 'chat_accepted' || notification.type === 'new_message') {\n        await openChat(notification.chat_room_id);\n      }\n\n      // Refresh notifications to remove the read one\n      await fetchNotifications(true);\n    } catch (error) {\n      console.error('Error handling notification click:', error);\n      setChatStatus({\n        type: 'error',\n        message: 'Failed to process notification: ' + error.message\n      });\n      setTimeout(() => setChatStatus(null), 5000);\n    }\n  }, [openChat, fetchNotifications]);\n\n  // Check for pending chat requests on mount\n  useEffect(() => {\n    if (user) {\n      // Initial load\n      fetchNotifications(true);\n      fetchActiveChats(true);\n\n      // Check for pending chat requests\n      const pendingChatId = localStorage.getItem('pendingChatRequest');\n      if (pendingChatId) {\n        fetchActiveChats(true).then(chats => {\n          const pendingChat = chats.find(c => c.id === pendingChatId);\n          if (pendingChat && pendingChat.isActive) {\n            openChat(pendingChatId);\n            localStorage.removeItem('pendingChatRequest');\n          }\n        });\n      }\n\n      // Set up polling interval\n      const intervalId = setInterval(() => {\n        fetchNotifications();\n        if (currentChat) {\n          fetchMessages(currentChat.id);\n        } else {\n          fetchActiveChats();\n        }\n      }, 10000);\n      return () => clearInterval(intervalId);\n    }\n  }, [user, currentChat, fetchNotifications, fetchActiveChats, fetchMessages, openChat]);\n  return /*#__PURE__*/_jsxDEV(ChatContext.Provider, {\n    value: {\n      activeChats,\n      notifications,\n      currentChat,\n      messages,\n      loading,\n      error,\n      chatStatus,\n      sendChatRequest,\n      acceptChatRequest,\n      declineChatRequest,\n      sendMessage,\n      fetchMessages,\n      openChat,\n      closeChat,\n      fetchActiveChats,\n      fetchNotifications,\n      handleNotificationClick\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 586,\n    columnNumber: 5\n  }, this);\n};\n_s(ChatProvider, \"onV7/gASV2Be2yu/DPls9eWSR0A=\");\n_c = ChatProvider;\nexport default ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","useCallback","useRef","api","AuthContext","jsxDEV","_jsxDEV","ChatContext","ChatProvider","children","_s","user","activeChats","setActiveChats","notifications","setNotifications","currentChat","setCurrentChat","messages","setMessages","loading","setLoading","error","setError","chatStatus","setChatStatus","lastRequest","chat","pendingRequests","enforceApiDelay","requestType","minDelay","current","console","log","now","Date","fetchNotifications","force","response","get","newNotifications","data","JSON","stringify","fetchActiveChats","newChats","chats","sendChatRequest","recipientId","type","message","post","localStorage","setItem","chatRoomId","setTimeout","_error$response","_error$response$data","ensureParticipantsCanChat","toISOString","find","c","id","isActive","hasJoined","refreshedChats","refreshedChat","acceptChatRequest","success","username","updatedChats","acceptedChat","i","Promise","resolve","retryChats","fetchMessages","msgError","warn","declineChatRequest","sendMessage","newMessage","chatMessage","prev","profiles","_error$response2","_error$response3","_error$response3$data","_error$response3$data2","status","includes","_error$response4","_error$response5","_error$response5$data","_error$response5$data2","openChat","closeChat","handleNotificationClick","notification","notificationId","chat_room_id","pendingChatId","getItem","then","pendingChat","removeItem","intervalId","setInterval","clearInterval","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/anubhav/project_6/auth-system/frontend/src/context/ChatContext.js"],"sourcesContent":["import React, { createContext, useState, useEffect, useContext, useCallback, useRef } from 'react';\nimport api from '../utils/api';\nimport { AuthContext } from './AuthContext';\n\nexport const ChatContext = createContext();\n\nexport const ChatProvider = ({ children }) => {\n  const { user } = useContext(AuthContext);\n  const [activeChats, setActiveChats] = useState([]);\n  const [notifications, setNotifications] = useState([]);\n  const [currentChat, setCurrentChat] = useState(null);\n  const [messages, setMessages] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [chatStatus, setChatStatus] = useState(null);\n  \n  // Add these to track last request times\n  const lastRequest = useRef({\n    chat: 0,\n    notifications: 0,\n    messages: 0\n  });\n  \n  // Add this to prevent concurrent requests\n  const pendingRequests = useRef({\n    chat: false,\n    notifications: false,\n    messages: false\n  });\n\n  // Enforce API delay function\n  const enforceApiDelay = useCallback(async (requestType, minDelay = 2000) => {\n    if (pendingRequests.current[requestType]) {\n      console.log(`${requestType} request already in progress, skipping`);\n      return false;\n    }\n    \n    const now = Date.now();\n    if (now - lastRequest.current[requestType] < minDelay) {\n      console.log(`Throttling ${requestType} request, too soon`);\n      return false;\n    }\n    \n    pendingRequests.current[requestType] = true;\n    lastRequest.current[requestType] = now;\n    return true;\n  }, []);\n\n  // Throttled fetch notifications\n  const fetchNotifications = useCallback(async (force = false) => {\n    if (!user) return [];\n    \n    if (pendingRequests.current.notifications) {\n      return notifications;\n    }\n    \n    const now = Date.now();\n    if (!force && now - lastRequest.current.notifications < 10000) {\n      return notifications;\n    }\n    \n    try {\n      pendingRequests.current.notifications = true;\n      const response = await api.get('/chat/notifications');\n      lastRequest.current.notifications = now;\n      \n      const newNotifications = response.data.notifications || [];\n      if (JSON.stringify(newNotifications) !== JSON.stringify(notifications)) {\n        setNotifications(newNotifications);\n      }\n      \n      return newNotifications;\n    } catch (error) {\n      console.error('Error fetching notifications:', error);\n      return [];\n    } finally {\n      pendingRequests.current.notifications = false;\n    }\n  }, [user, notifications]);\n\n  // Throttled fetch active chats\n  const fetchActiveChats = useCallback(async (force = false) => {\n    if (!user) return [];\n    \n    if (pendingRequests.current.chat) {\n      return activeChats;\n    }\n    \n    const now = Date.now();\n    if (!force && now - lastRequest.current.chat < 10000) {\n      return activeChats;\n    }\n    \n    try {\n      pendingRequests.current.chat = true;\n      setLoading(true);\n      \n      const response = await api.get('/chat/active');\n      lastRequest.current.chat = now;\n      \n      const newChats = response.data.chats || [];\n      \n      if (JSON.stringify(newChats) !== JSON.stringify(activeChats)) {\n        setActiveChats(newChats);\n      }\n      \n      return newChats;\n    } catch (error) {\n      console.error('Error fetching active chats:', error);\n      setError('Failed to fetch active chats');\n      return [];\n    } finally {\n      setLoading(false);\n      pendingRequests.current.chat = false;\n    }\n  }, [user, activeChats]);\n\n  // Send a chat request to another user\n  const sendChatRequest = async (recipientId) => {\n    if (!user || !recipientId) return;\n    \n    try {\n      setLoading(true);\n      setChatStatus({\n        type: 'sending',\n        message: 'Sending chat request...'\n      });\n      \n      const response = await api.post('/chat/request', { recipientId });\n      \n      await fetchActiveChats(true);\n      \n      localStorage.setItem('pendingChatRequest', response.data.chatRoomId);\n      \n      setChatStatus({\n        type: 'success',\n        message: 'Chat request sent successfully! Waiting for acceptance.'\n      });\n      \n      setTimeout(() => setChatStatus(null), 3000);\n      \n      return response.data;\n    } catch (error) {\n      console.error('Error sending chat request:', error);\n      \n      setChatStatus({\n        type: 'error',\n        message: 'Failed to send chat request: ' + (error.response?.data?.message || error.message)\n      });\n      \n      setTimeout(() => setChatStatus(null), 5000);\n      \n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Accept a chat request with enhanced error handling\n // Replace the acceptChatRequest function in your ChatContext.js file with this improved version\n// Add this helper function to your ChatContext.js\nconst ensureParticipantsCanChat = async (chatRoomId) => {\n  try {\n    console.log(`[${new Date().toISOString()}] Ensuring all participants can chat in room ${chatRoomId}`);\n    \n    // Get the chat from active chats\n    const chat = activeChats.find(c => c.id === chatRoomId);\n    \n    if (!chat) {\n      console.error('Chat not found in active chats');\n      return false;\n    }\n    \n    // If chat is already active and user has joined, we're good\n    if (chat.isActive && chat.hasJoined) {\n      console.log('Chat is already active and user has joined');\n      return true;\n    }\n    \n    // If we need to refresh the chat status\n    const refreshedChats = await fetchActiveChats(true);\n    const refreshedChat = refreshedChats.find(c => c.id === chatRoomId);\n    \n    if (!refreshedChat) {\n      console.error('Chat not found after refresh');\n      return false;\n    }\n    \n    return refreshedChat.isActive && refreshedChat.hasJoined;\n  } catch (error) {\n    console.error('Error ensuring participants can chat:', error);\n    return false;\n  }\n};\n\n// Replace the acceptChatRequest function with this improved version\nconst acceptChatRequest = async (chatRoomId) => {\n  if (!user || !chatRoomId) {\n    console.error('Cannot accept chat: missing user or chatRoomId');\n    return { success: false, error: 'Missing required data' };\n  }\n  \n  try {\n    setLoading(true);\n    setChatStatus({\n      type: 'accepting',\n      message: 'Accepting chat request...'\n    });\n    \n    console.log(`[${new Date().toISOString()}] User ${user.username || 'itsanubhav009'} is accepting chat request ${chatRoomId}`);\n    \n    // Make the API call to accept the chat request\n    const response = await api.post('/chat/accept', { chatRoomId });\n    console.log('Accept response from server:', response.data);\n    \n    // Force refresh notifications to remove the accepted notification\n    await fetchNotifications(true);\n    \n    // Fetch active chats to get the updated chat list\n    const updatedChats = await fetchActiveChats(true);\n    console.log('Updated chats after acceptance:', updatedChats);\n    \n    // Find the accepted chat in the updated list\n    let acceptedChat = updatedChats.find(c => c.id === chatRoomId);\n    \n    if (acceptedChat) {\n      console.log('Found accepted chat:', acceptedChat);\n      \n      // If chat isn't active yet, we need to wait\n      if (!acceptedChat.isActive || !acceptedChat.hasJoined) {\n        console.log('Chat is not fully active yet. Waiting...');\n        \n        setChatStatus({\n          type: 'waiting',\n          message: 'Waiting for chat room to activate...'\n        });\n        \n        // Wait for up to 5 seconds with multiple retries\n        for (let i = 0; i < 5; i++) {\n          // Wait 1 second\n          await new Promise(resolve => setTimeout(resolve, 1000));\n          \n          // Refresh the chats again\n          const retryChats = await fetchActiveChats(true);\n          acceptedChat = retryChats.find(c => c.id === chatRoomId);\n          \n          if (acceptedChat && acceptedChat.isActive && acceptedChat.hasJoined) {\n            console.log('Chat is now active!');\n            break;\n          }\n          \n          console.log(`Attempt ${i+1}: Chat still not fully active`);\n        }\n      }\n      \n      // Set as current chat\n      setCurrentChat(acceptedChat);\n      \n      // Try to fetch messages\n      try {\n        await fetchMessages(chatRoomId, true);\n      } catch (msgError) {\n        console.warn('Could not fetch messages yet:', msgError);\n      }\n      \n      setChatStatus({\n        type: 'success',\n        message: 'Chat request accepted successfully!'\n      });\n      \n      // Clear status after a delay\n      setTimeout(() => {\n        setChatStatus(null);\n      }, 3000);\n      \n      return { success: true, chat: acceptedChat };\n    } else {\n      console.warn('Accepted chat not found in active chats list');\n      \n      setChatStatus({\n        type: 'error',\n        message: 'Could not find the chat after accepting.'\n      });\n      \n      setTimeout(() => {\n        setChatStatus(null);\n      }, 5000);\n      \n      return {\n        success: false,\n        error: 'Chat not found after acceptance'\n      };\n    }\n  } catch (error) {\n    console.error('Error accepting chat request:', error);\n    \n    setChatStatus({\n      type: 'error',\n      message: 'Failed to accept chat request: ' + (error.message || 'Unknown error')\n    });\n    \n    setTimeout(() => {\n      setChatStatus(null);\n    }, 5000);\n    \n    return {\n      success: false,\n      error: error.message || 'Unknown error'\n    };\n  } finally {\n    setLoading(false);\n  }\n};\n\n  // Decline a chat request\n  const declineChatRequest = async (chatRoomId) => {\n    if (!user || !chatRoomId) return;\n    \n    try {\n      setLoading(true);\n      setChatStatus({\n        type: 'declining',\n        message: 'Declining chat request...'\n      });\n      \n      await api.post('/chat/decline', { chatRoomId });\n      \n      await fetchNotifications(true);\n      \n      setChatStatus({\n        type: 'success',\n        message: 'Chat request declined'\n      });\n      \n      setTimeout(() => setChatStatus(null), 3000);\n      \n      return { success: true };\n    } catch (error) {\n      console.error('Error declining chat request:', error);\n      \n      setChatStatus({\n        type: 'error',\n        message: 'Failed to decline chat request: ' + (error.message || 'Unknown error')\n      });\n      \n      setTimeout(() => setChatStatus(null), 5000);\n      \n      throw error;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Send a message in a chat\n  const sendMessage = async (chatRoomId, message) => {\n    if (!user || !chatRoomId || !message) return;\n    \n    try {\n      const response = await api.post('/chat/send', { chatRoomId, message });\n      \n      const newMessage = response.data.chatMessage;\n      setMessages(prev => [\n        ...prev, \n        {...newMessage, profiles: { username: user.username }}\n      ]);\n      \n      return response.data;\n    } catch (error) {\n      console.error('Error sending message:', error);\n      \n      if (error.response?.status === 403 && error.response?.data?.message?.includes('not active')) {\n        setChatStatus({\n          type: 'waiting',\n          message: 'Waiting for recipient to accept your chat request...'\n        });\n        \n        setTimeout(() => setChatStatus(null), 5000);\n      } else {\n        setError('Failed to send message: ' + error.message);\n      }\n      \n      throw error;\n    }\n  };\n\n  // Fetch messages for a chat\n  const fetchMessages = useCallback(async (chatRoomId, force = false) => {\n    if (!user || !chatRoomId) return;\n    \n    if (currentChat && !force && !(await enforceApiDelay('messages'))) {\n      return messages;\n    }\n    \n    try {\n      setLoading(true);\n      \n      const response = await api.get(`/chat/messages/${chatRoomId}`);\n      \n      if (response.data.messages) {\n        setMessages(response.data.messages);\n        return response.data.messages;\n      } else {\n        setMessages([]);\n        return [];\n      }\n    } catch (error) {\n      console.error('Error fetching messages:', error);\n      \n      if (error.response?.status === 403 && error.response?.data?.message?.includes('not active')) {\n        setChatStatus({\n          type: 'waiting',\n          message: 'This chat room is not active yet. Waiting for acceptance...'\n        });\n        \n        setTimeout(() => setChatStatus(null), 5000);\n        setMessages([]);\n      } else {\n        setError('Failed to fetch messages: ' + error.message);\n        setMessages([]);\n      }\n      \n      return [];\n    } finally {\n      setLoading(false);\n      pendingRequests.current.messages = false;\n    }\n  }, [user, messages, currentChat, enforceApiDelay]);\n\n  // Open a chat with improved error handling for inactive chats\n  const openChat = useCallback(async (chatRoomId) => {\n    try {\n      setLoading(true);\n      \n      let chat = activeChats.find(c => c.id === chatRoomId);\n      \n      if (!chat) {\n        const updatedChats = await fetchActiveChats(true);\n        chat = updatedChats.find(c => c.id === chatRoomId);\n      }\n      \n      if (chat) {\n        // Check if the chat is active\n        if (!chat.isActive) {\n          // If the chat is not active, check if user has joined\n          if (chat.hasJoined) {\n            // If the user has joined, they're waiting for the other person\n            setChatStatus({\n              type: 'waiting',\n              message: 'Waiting for the other person to accept your chat request...'\n            });\n            \n            setCurrentChat(chat);\n            setMessages([]);\n            \n            setTimeout(() => setChatStatus(null), 5000);\n            \n            return { \n              success: true, \n              chat, \n              status: 'waiting' \n            };\n          } else {\n            // If the user hasn't joined, they need to accept the request first\n            setChatStatus({\n              type: 'pending',\n              message: 'You need to accept this chat request first'\n            });\n            \n            await acceptChatRequest(chatRoomId);\n            return { \n              success: true, \n              chat, \n              status: 'accepted' \n            };\n          }\n        } else {\n          // Chat is active, proceed normally\n          setCurrentChat(chat);\n          await fetchMessages(chatRoomId);\n          \n          return { \n            success: true, \n            chat, \n            status: 'active' \n          };\n        }\n      } else {\n        setChatStatus({\n          type: 'error',\n          message: 'Chat room not found'\n        });\n        \n        setTimeout(() => setChatStatus(null), 5000);\n        \n        return { \n          success: false, \n          error: 'Chat not found' \n        };\n      }\n    } catch (error) {\n      console.error('Error opening chat:', error);\n      \n      setChatStatus({\n        type: 'error',\n        message: 'Failed to open chat: ' + error.message\n      });\n      \n      setTimeout(() => setChatStatus(null), 5000);\n      \n      return { \n        success: false, \n        error: error.message \n      };\n    } finally {\n      setLoading(false);\n    }\n  }, [activeChats, fetchActiveChats, fetchMessages, acceptChatRequest]);\n\n  // Close the current chat\n  const closeChat = () => {\n    setCurrentChat(null);\n    setMessages([]);\n  };\n  \n  // Handle notification click\n  const handleNotificationClick = useCallback(async (notification) => {\n    if (!notification) return;\n    \n    try {\n      // Mark notification as read\n      await api.post('/chat/markNotificationRead', { notificationId: notification.id });\n      \n      // If it's a chat request, open the chat (which will handle acceptance if needed)\n      if (notification.type === 'chat_request' || notification.type === 'chat_accepted' || notification.type === 'new_message') {\n        await openChat(notification.chat_room_id);\n      }\n      \n      // Refresh notifications to remove the read one\n      await fetchNotifications(true);\n    } catch (error) {\n      console.error('Error handling notification click:', error);\n      setChatStatus({\n        type: 'error',\n        message: 'Failed to process notification: ' + error.message\n      });\n      \n      setTimeout(() => setChatStatus(null), 5000);\n    }\n  }, [openChat, fetchNotifications]);\n\n  // Check for pending chat requests on mount\n  useEffect(() => {\n    if (user) {\n      // Initial load\n      fetchNotifications(true);\n      fetchActiveChats(true);\n      \n      // Check for pending chat requests\n      const pendingChatId = localStorage.getItem('pendingChatRequest');\n      if (pendingChatId) {\n        fetchActiveChats(true).then(chats => {\n          const pendingChat = chats.find(c => c.id === pendingChatId);\n          if (pendingChat && pendingChat.isActive) {\n            openChat(pendingChatId);\n            localStorage.removeItem('pendingChatRequest');\n          }\n        });\n      }\n      \n      // Set up polling interval\n      const intervalId = setInterval(() => {\n        fetchNotifications();\n        \n        if (currentChat) {\n          fetchMessages(currentChat.id);\n        } else {\n          fetchActiveChats();\n        }\n      }, 10000);\n      \n      return () => clearInterval(intervalId);\n    }\n  }, [user, currentChat, fetchNotifications, fetchActiveChats, fetchMessages, openChat]);\n  \n  return (\n    <ChatContext.Provider\n      value={{\n        activeChats,\n        notifications,\n        currentChat,\n        messages,\n        loading,\n        error,\n        chatStatus,\n        sendChatRequest,\n        acceptChatRequest,\n        declineChatRequest,\n        sendMessage,\n        fetchMessages,\n        openChat,\n        closeChat,\n        fetchActiveChats,\n        fetchNotifications,\n        handleNotificationClick\n      }}\n    >\n      {children}\n    </ChatContext.Provider>\n  );\n};\n\nexport default ChatProvider;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}